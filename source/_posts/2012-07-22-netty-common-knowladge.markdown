
---
layout: post
title: "Netty: Структура проекта"
date: 2012-07-22 10:36
comments: true
published: true
categories: Netty
---
[Netty](http://netty.io) - framework для написания приложений, взаимодействующих по сети. Это может быть и балансировщик нагрузки, и сетевой паук, и практически любая другая архитектура, основанная на понятии client/server.

<!--more-->

В основе лежит `java.io` и `java.nio`. Выбор базового механизма осуществляется путем использования конкретных реализаций ключевых компонентов. Подход к их использованию скрыт под абстракцией и интерфейсами, так что перейти от одного к другому не составит труда в отличие от того, как бы это было реализовано в *Java*.

Все сетевые операции асинхронны. Управление асинхронным взаимодействием осуществляется на основе событийной модели или с использованием *Future* объектов подобных *Future* объектам в *Java*.

Workflow типичной программы на Netty:

1. Создается новый экземпляр `ChannelFactory` - фабрика, порождающая каналы - базовые сущности библиотеки. Именно они скрывают за собой особенность реализации процесса сетевого взаимодействия. По большому счету, канал - это абстракция над соединением, куда можно писать и откуда можно читать информацию. Очевдно, что реализация `ChannelFactory` также отражает используемые технологии. Например, для использования java.nio используется `NioServerSocketChannelFactory`.
2. Создается новый экземпляр `Bootstrap` объекта - вспомогательный класс, который упрощает процесс конфигурирования приложения. Обязательным параметром Bootstrap объекта является `ChannelFactory`, с помощью которого приложение будет открывать новые сетевые соединения.
3. Задается фабрика `ChannelPipelineFactory`, которая является ключевым элементом в событийной модели *Netty*. Обработчики событий `ChannelHandler` организованы подобно обработчикам *JUnit* или *Mockito* (возможно, не совсем равноценное сравнение), т.е. каждому методу обработчика соответствует событие. Переопределяя эти методы, мы подписываемся на связанные с ними события. *Netty* оперирует цепочкой обработчиков `ChannelPipeline`, т.е. отреагировав на событие, один обработчик передает управление другому обработчику в цепочке. Реализуя фабрику pipeline'ов, мы можем определить свои обработчики в цепочке.
4. Второстепенная конфигурация приложения через `Bootstrap`.
5. Запуск сетевого приложения.
6. Завершение сетевого приложения.

*Netty* потрясающе документирован. Его документация по-настоящему самодостаточна и понятна. Крайне рекомендую изучить примеры использования этой библиотеки в [официальной документации проекта](http://static.netty.io/3.5/guide/). Кстати о версиях. На данный момент, финальная версия - `3.5.2`. Последний релиз был 5го июля 2012 года. Но вместе с тем идет разработка 4ой версии *Netty*. К сожалению, эта версия находится в Alpha стадии и не имеет какого либо руководства пользователя. При этом, структура классов немного поменялась, поэтому просто так использовать новую версию не получится.

Исходные коды хостятся на [Github](https://github.com/netty/netty). В качестве build tool используется *Maven*. Проект организован в виде нескольких модулей. Т.е. внутри корневого пакета `io.netty` пакеты разделены на модули. Каждый модуль находится в отдельном каталоге, который реализован также ввиде maven проекта. Внутри центрального pom файла объявляются все дочерние модули:

{% codeblock %}
<modules>
  <module>common</module> - утилитарные классы + логирование
  <module>buffer</module> - базовая структура данных и все, что требуется для ее работы
  <module>codec</module> - реализации обработчиков, преобразующие данные в цепочке обработки
  <module>codec-http</module> - реализация обработчиков и утилитарных методов, специфичных для взаимодействия поверх HTTP
  <module>transport</module> - ядро *Netty*, управляющее передачей данных и соединением (Bootstrap, Channel, ChannelHandler)
  <module>handler</module> - утилитарные классы, необходимые для работы обработчиков
  <module>example</module> - примеры программ, использующих *Netty*
  <module>testsuite</module> - тесты на *JUnit*. Тестов немного, но они есть.
  <module>all</module> - сборка всех модулей в один jar'файл
  <module>tarball</module> - сборка в tarball архив
</modules>
{% endcodeblock %}
