---
layout: post
title: "Mockito: Обработка методов"
date: 2012-07-06 00:10
comments: true
published: true
categories: Mockito
---
<p>Вместе с mock'ом создается обработчик его событий. Это один обработчик на все методы мока. В итоге, мы имеем объект класса <code>MockHandlerImpl</code>, который обернут wrapper'ами.</p>

<!--more-->

<p>В момент вызова метода mock объекта вызывается <code>MockHandlerImpl#handle</code>. Но этот метод вызывается не напрямую а из объекта <code>MethodInterceptor</code>. Именно с этими обработчиками работает созданный <em>CGLib</em> библиотекой proxy объект. В <a href="https://code.google.com/p/mockito/" rel="nofollow">Mockito</a> есть собственная реализация <code>MethodInterceptor</code> - <code>MethodInterceptorFilter</code>, которая хранит внутри себя обработчик <code>MockHandlerImpl</code> и настройки вызова. Итак, что же происходит в момент вызова метода mock объекта? Вызывается метод <code>MethodInterceptorFilter#intercept</code>, куда передается ссылка на объект, в котором был вызван метод, ссылка на объект вызванного метода, массив переданных аргументов и объект <code>MethodProxy</code>, который позволяет получить ссылку на реальный метод mock объекта. <code>MethodInterceptorFilter</code> отделяет реализацию получения необходимых параметров вызова от самого обработчика. Далее все эти параметры помещаются в независимый от механизма создания proxy класс <code>Invocation</code>. Этот объект передается методу обработчика <code>MockHandlerImpl#handle</code>, который выполняет основную логику стаббированных методов.</p>

<p>Стоит понимать, что в Mockito есть как минимум 3 ситуации, когда вызов метода одного и того же mock объекта должен интерпретироваться по разному:</p>

<ol class="enum">
    <li>в конструкции <code>when(mock.method(matcher))</code></li>
    <li>в конструкции <code>verify(mock).method(matcher)</code></li>
    <li>прямой вызов <code>mock.method(args...)</code> в тестируемом объекте</li>
</ol>

<p>В обработчике(метод <code>handle</code>) обрабатываются все эти ситуации. В одной из статей мы уже рассматривали объекты ответов - <code>Answer</code>, которые определяются в конструкции when. В конструкции verify хранятся условия проверки. Плюс ко всему, есть matcher'ы, которые тоже накапливаются. Есть и другие параметры, которые должны быть переданы в обработчик. Странное решение, размывающее логику обработчика - это хранение этих артефактов в singleton объектах, доступ к которым имеют все компоненты системы одновременно. Основным таким объектом является MockingProgress. Этот объект мы уже рассматривали со стороны оповещения слушателей о событии создания mock'а. Он хранит в себе настройки verify блока и список matcher'ов. Плюс ко всему, т.к. эти объекты по большому счету нужны только в момент обработки stub'а, то нужно следить чтобы хранимые объекты не попали случайно в другой stub, поэтому Mockito хранит текущее состояние процесса стаббинга. Состояние определяется по наличию тех или иных объектов в реализации <code>MockingProgress</code>. К примеру, если объект <code>VerificationMode</code> не null, то объект в состоянии проверки. После извлечения хранимых объектов в них проставляется null, и объект готов к следующим процессам. Под процессом над стаббированным методом понимается один из трех процессов перечисленных в списке вызова обработчика метода mock'а выше в статье.</p>

<p>В каждом MockHandler'е создается InvocationContainer, который хранит в себе все ответы. В этот же контейнер переносятся все matcher'ы при их обработке. Этот же объект хранит информацию, которая проверяется в VerificationMode. Если задан VerificationMode, то выполняется проверка. Иначе вызывается метод инкрементирующий статистические данные о вызове методов.</p>

<blockquote>
    Стоит заметить, что matcher'ы - объекты, которые позволяют задавать аргументы стаббируемых методов в виде выражений, реализуются на базе библиотеки <a href="http://code.google.com/p/hamcrest" rel="nofollow">Hamcrest</a>. Насколько я знаю, многие тестирующие framework'и используют эту библиотеку. Mockito лишь расширяет её своими matcher'ами.
</blockquote>

<p>Далее вызывается поиск Answer объекта по объекту Invocation: </p>

{% codeblock %}
StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);
{% endcodeblock %}

<p>Где ищется соответствующий объект ответа для данного мока, для данного метода с аргумента, matcher которого соответствует переданным аргументам. Напомню, что вся эта информация хранится в объекте invocation с одной стороны и в объекте ответа(точнее в его обертке, которая используется во внутренней реализации) с другой.</p>

<p>Если ответ найден, то он вызывается с передачей ему объекта invocation. Иначе получаем ответ по-умолчанию и вызываем его:</p>

{% codeblock %}
if (stubbedInvocation != null) {
    stubbedInvocation.captureArgumentsFrom(invocation);
    return stubbedInvocation.answer(invocation);
} else {
    Object ret = mockSettings.getDefaultAnswer().answer(invocation);
    invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
    return ret;
}
{% endcodeblock %}

<p>Объект, возвращаемый ответом, и есть результат метода mock'а. Он и возвращается из функции.</p>

<blockquote>        
Это последняя статья цикла <em>Mockito</em>. Мы увидели и хардкод и дублирование и, возможно, неудачные архитектурные решения. Чего стоит абстрагирование создания mock объектов, где базовые общие классы тесно переплетены с логикой библиотки <a href="http://cglib.sourceforge.net/" rel="nofollow">CGLib</a>. Замена <em>CGLib</em> альтернативами не будет легким занятием. Но вместе с тем <em>Mockito</em> является типичным примером тестирующего framework'а, который позволяет понять принципы работы подобных библиотек.
</blockquote>

<p>Если остались вопросы, то не стесняйтесь их задавать в комментариях, twitter'e/Google Plus'e или по почте.</p>