<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mockito | CodeInsider]]></title>
  <link href="http://knowlix.github.io/blog/categories/mockito/atom.xml" rel="self"/>
  <link href="http://knowlix.github.io/"/>
  <updated>2013-09-22T18:40:47+04:00</updated>
  <id>http://knowlix.github.io/</id>
  <author>
    <name><![CDATA[Code insiders]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mockito: Обработка методов]]></title>
    <link href="http://knowlix.github.io/blog/2012/07/06/mockito-methods-interception/"/>
    <updated>2012-07-06T00:10:00+04:00</updated>
    <id>http://knowlix.github.io/blog/2012/07/06/mockito-methods-interception</id>
    <content type="html"><![CDATA[<p>Вместе с mock'ом создается обработчик его событий. Это один обработчик на все методы мока. В итоге, мы имеем объект класса <code>MockHandlerImpl</code>, который обернут wrapper'ами.</p>




<!--more-->




<p>В момент вызова метода mock объекта вызывается <code>MockHandlerImpl#handle</code>. Но этот метод вызывается не напрямую а из объекта <code>MethodInterceptor</code>. Именно с этими обработчиками работает созданный <em>CGLib</em> библиотекой proxy объект. В <a href="https://code.google.com/p/mockito/" rel="nofollow">Mockito</a> есть собственная реализация <code>MethodInterceptor</code> - <code>MethodInterceptorFilter</code>, которая хранит внутри себя обработчик <code>MockHandlerImpl</code> и настройки вызова. Итак, что же происходит в момент вызова метода mock объекта? Вызывается метод <code>MethodInterceptorFilter#intercept</code>, куда передается ссылка на объект, в котором был вызван метод, ссылка на объект вызванного метода, массив переданных аргументов и объект <code>MethodProxy</code>, который позволяет получить ссылку на реальный метод mock объекта. <code>MethodInterceptorFilter</code> отделяет реализацию получения необходимых параметров вызова от самого обработчика. Далее все эти параметры помещаются в независимый от механизма создания proxy класс <code>Invocation</code>. Этот объект передается методу обработчика <code>MockHandlerImpl#handle</code>, который выполняет основную логику стаббированных методов.</p>




<p>Стоит понимать, что в Mockito есть как минимум 3 ситуации, когда вызов метода одного и того же mock объекта должен интерпретироваться по разному:</p>




<ol class="enum">
    <li>в конструкции <code>when(mock.method(matcher))</code></li>
    <li>в конструкции <code>verify(mock).method(matcher)</code></li>
    <li>прямой вызов <code>mock.method(args...)</code> в тестируемом объекте</li>
</ol>




<p>В обработчике(метод <code>handle</code>) обрабатываются все эти ситуации. В одной из статей мы уже рассматривали объекты ответов - <code>Answer</code>, которые определяются в конструкции when. В конструкции verify хранятся условия проверки. Плюс ко всему, есть matcher'ы, которые тоже накапливаются. Есть и другие параметры, которые должны быть переданы в обработчик. Странное решение, размывающее логику обработчика - это хранение этих артефактов в singleton объектах, доступ к которым имеют все компоненты системы одновременно. Основным таким объектом является MockingProgress. Этот объект мы уже рассматривали со стороны оповещения слушателей о событии создания mock'а. Он хранит в себе настройки verify блока и список matcher'ов. Плюс ко всему, т.к. эти объекты по большому счету нужны только в момент обработки stub'а, то нужно следить чтобы хранимые объекты не попали случайно в другой stub, поэтому Mockito хранит текущее состояние процесса стаббинга. Состояние определяется по наличию тех или иных объектов в реализации <code>MockingProgress</code>. К примеру, если объект <code>VerificationMode</code> не null, то объект в состоянии проверки. После извлечения хранимых объектов в них проставляется null, и объект готов к следующим процессам. Под процессом над стаббированным методом понимается один из трех процессов перечисленных в списке вызова обработчика метода mock'а выше в статье.</p>




<p>В каждом MockHandler'е создается InvocationContainer, который хранит в себе все ответы. В этот же контейнер переносятся все matcher'ы при их обработке. Этот же объект хранит информацию, которая проверяется в VerificationMode. Если задан VerificationMode, то выполняется проверка. Иначе вызывается метод инкрементирующий статистические данные о вызове методов.</p>




<blockquote>
    Стоит заметить, что matcher'ы - объекты, которые позволяют задавать аргументы стаббируемых методов в виде выражений, реализуются на базе библиотеки <a href="http://code.google.com/p/hamcrest" rel="nofollow">Hamcrest</a>. Насколько я знаю, многие тестирующие framework'и используют эту библиотеку. Mockito лишь расширяет её своими matcher'ами.
</blockquote>




<p>Далее вызывается поиск Answer объекта по объекту Invocation: </p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Где ищется соответствующий объект ответа для данного мока, для данного метода с аргумента, matcher которого соответствует переданным аргументам. Напомню, что вся эта информация хранится в объекте invocation с одной стороны и в объекте ответа(точнее в его обертке, которая используется во внутренней реализации) с другой.</p>




<p>Если ответ найден, то он вызывается с передачей ему объекта invocation. Иначе получаем ответ по-умолчанию и вызываем его:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (stubbedInvocation != null) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>stubbedInvocation.captureArgumentsFrom(invocation);
</span><span class='line'>return stubbedInvocation.answer(invocation);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>} else {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>Object ret = mockSettings.getDefaultAnswer().answer(invocation);
</span><span class='line'>invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
</span><span class='line'>return ret;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Объект, возвращаемый ответом, и есть результат метода mock'а. Он и возвращается из функции.</p>




<blockquote>        
Это последняя статья цикла <em>Mockito</em>. Мы увидели и хардкод и дублирование и, возможно, неудачные архитектурные решения. Чего стоит абстрагирование создания mock объектов, где базовые общие классы тесно переплетены с логикой библиотки <a href="http://cglib.sourceforge.net/" rel="nofollow">CGLib</a>. Замена <em>CGLib</em> альтернативами не будет легким занятием. Но вместе с тем <em>Mockito</em> является типичным примером тестирующего framework'а, который позволяет понять принципы работы подобных библиотек.
</blockquote>




<p>Если остались вопросы, то не стесняйтесь их задавать в комментариях, twitter'e/Google Plus'e или по почте.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mockito: Как создаются mock'и]]></title>
    <link href="http://knowlix.github.io/blog/2012/06/30/mockito-mocks-creating/"/>
    <updated>2012-06-30T21:17:00+04:00</updated>
    <id>http://knowlix.github.io/blog/2012/06/30/mockito-mocks-creating</id>
    <content type="html"><![CDATA[<p>Работа с <a href="https://code.google.com/p/mockito/" rel="nofollow">Mockito</a> начинается, как ни странно, с класса <code>org.mockito.Mockito</code>. Этот класс содержит в себе несколько статичных методов, которые обычно и импортируются в тест-класс. Первое же, что бросается в глаза, это огромные JavaDoc комментарии. Разработчики решили вести настоящий Tutorial прямо в коде. Обнаружить код среди такого обилия комментариев без использования инструментов IDE весьма непросто. Класс <em>Mockito</em> делегирует все вызовы классу <code>org.mockito.internal.MockitoCore</code>. Если класс <em>Mockito</em> - точка входа внешнего API, то <code>MockitoCore</code> - точка входа во внутреннюю реализацию проекта. </p>




<!--more-->




<p>Создание mock объекта начинается с вызова метода <code>mock(Class&lt;T&gt; typeToMock, MockSettings settings)</code>, где</p>




<ul class="enum">
    <li>typeToMock - класс типа будущего mock'а</li>
    <li>settings - настройки mock'a</li>
</ul>




<p>Типичный вызов создания мока выглядит так:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Mockito.mock(SomeClass.class)</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>При этом настройки mock'а инициализируются по умолчанию с помощью метода <code>Mockito.withSettings()</code>, который возвращает реализацию интерфейсов настроек. А интерфейсов класса с настройками mock объектов два - <code>org.mockito.MockSettings</code> и <code>org.mockito.mock.MockCreationSettings</code>. Первый определяет методы установки параметров mock'ов, второй определяет интерфейс для доступа к этим параметрам без возможности их изменения. Соответственно, запись значений в объект производится через первый интерфейс, а все остальные классы работают с параметрами через второй интерфейс, чтобы ничего в нем случайно не изменить. Настройки можно задавать вручную при создании mock объекта. В частности можно указать произвольное имя mock'а, чтобы логи выполнения тестов стали понятнее.</p>




<p>При создании mock'а, все его методы stubb'ируются. Результат вызова метода определяется Answer объектом. Для важных методов тестирования мы задаем <code>Answer</code> объект вручную через конструкцию <code>Mockito.when(Matcher).thenAnswer(Answer)</code>, для других же объектов вызывается <code>Answer</code> по умолчанию. Конкретная реализация ответа также определяется в настройках mock'а и её можно переопределить. В настройках по умолчанию используется <code>org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer</code>. Этот ответ в свою очередь делегирует запрос реализации ответа, которая определена в глобальном объекте конфигурации, который был рассмотрен в статье <a href="http://queuepy.com/blog/2012/06/26/mockito-init-mocks/">Mockito: Обработка аннотаций</a>. В конфигурации же определена реализация <code>org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues</code>, которая возвращает пустые значения для разных типов объектов.</p>




<p>Помимо <code>GloballyConfiguredAnswer</code>, в <em>Mockito</em>, реализовано ещё несколько реализаций ответов, ссылки на эти объекты хранятся в Enum'е <code>org.mockito.Answers</code>. Также в <em>Mockito</em> ещё имеются и внутренние реализации ответов, такие как <code>ReturnsEmptyValues</code> и <code>ReturnsMoreEmptyValues</code>. Последний делегирует запрос <code>ReturnsEmptyValues</code> и дополняет его логику определением еще нескольких типов данных. Дело в том, что <code>ReturnsEmptyValues</code> возвращает null для всех объектов, кроме определенных реализаций коллекций, примитивных типов и их оберток. В какой-то момент разработчики решили поддержать еще строки и массивы, но так как кто-то, скорее всего, успел написать тесты с учетом этой специфики, то просто обновить существующую реализацию уже недостаточно. Пришлось создавать новый тип ответа <code>ReturnsMoreEmptyValues</code>. Новый ответ сейчас используется в реализации ответа <code>ReturnsSmartNulls</code>, который вместо null пытается создать и вернуть mock'реализацию данного типа.</p>




<p>Есть и другие внутренние реализации ответов, но в них нет ничего интересного. Так же имеется возможность задать в настройках объекты - слушатели, которые будут оповещены в момент вызова метода. Эти объекты реализуют интерфейс <code>org.mockito.MockSettings.InvocationListener</code>.</p>




<p>Помимо прочего, базовый класс настроек имеет метод самопроверки, который в аргументе принимает класс объекта, mock которого планируется создать, и проверяет возможность создания mock'а с данными настройками. В случае успешной проверки создается новый экземпляр объекта настроек, куда устанавливается объект имени mock'а и обработанные настройки, определенные раннее. Объект имени мока с интерфейсом <code>org.mockito.internal.util.MockName</code> служит для хранения имени мока и для выполнения некоторых операций по обработке имени мока.</p>




<p>Основной объект системы, выполняющий создание объекта, реализует интерфейс <code>org.mockito.plugins.MockMaker</code>, но напрямую с этим объектом работает только утилитарный класс <code>org.mockito.internal.util.MockUtil</code>. Именно метод <code>createMock</code> класса <code>MockUtil</code> вызывается в <code>MockitoCore#mock</code>. В первую очередь создается объект с интерфейсом <code>org.mockito.invocation.MockHandler</code>, который перехватывает вызов стаббированных методов в mock объекте. Объекты перехватчиков создаются фабрикой <code>org.mockito.internal.handler.MockHandlerFactory</code>. Создается базовая реализация обработчика <code>org.mockito.internal.handler.MockHandlerImpl</code> и оборачивается разными wrapper'ами (паттерн <em>Wrapper</em>) для навешивания дополнительного функционала. На данный момент используются следующие обертки:</p>




<ul class="enum">
    <li><code>org.mockito.internal.handler.NullResultGuardian</code> для предотвращения возвращения null'овых значений из методов, которые возвращают примитивные типы или их обертки.</li>

    <li><code>org.mockito.internal.handler.MockHandlerFactory</code> оповещает слушателей, объявленных в настройках о вызове метода.</li>
</ul>




<p>Далее вызывается метод <code>MockMaker#createMock</code>, куда передаются настройки и <code>MockHandler</code>. Объект <code>MockMaker'а</code> создается в статичном поле класса <code>MockUtil</code> с помощью <code>ClassPathLoader</code>, который уже использовался для загрузки пользовательской реализации класса конфигурации. Метод <code>СlassPathLoader#getMockMaker</code> возвращает заранее загруженную реализацию <code>MockMaker'a</code>. Так же как и с объектом конфигурации, имеется возможность использовать свою реализацию <code>MockMaker'а</code>, но принцип загрузки отличается:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static &lt;T> List&lt;T> loadImplementations(Class&lt;T> service) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>ClassLoader loader = Thread.currentThread().getContextClassLoader();
</span><span class='line'>if (loader == null) {
</span><span class='line'>    loader = ClassLoader.getSystemClassLoader();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>Enumeration&lt;URL&gt; resources;
</span><span class='line'>try {
</span><span class='line'>    resources = loader.getResources("mockito-extensions/" + service.getName());
</span><span class='line'>} catch (IOException e) {
</span><span class='line'>    throw new MockitoException("Failed to load " + service, e);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>List&lt;T&gt; result = new ArrayList&lt;T&gt;();
</span><span class='line'>for (URL resource : Collections.list(resources)) {
</span><span class='line'>    InputStream in = null;
</span><span class='line'>    try {
</span><span class='line'>        in = resource.openStream();
</span><span class='line'>        for (String line : readerToLines(new InputStreamReader(in, "UTF-8"))) {
</span><span class='line'>            String name = stripCommentAndWhitespace(line);
</span><span class='line'>            if (name.length() != 0) {
</span><span class='line'>                result.add(service.cast(loader.loadClass(name).newInstance()));
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    } catch (Exception e) {
</span><span class='line'>        throw new MockitoConfigurationException(
</span><span class='line'>                "Failed to load " + service + " using " + resource, e);
</span><span class='line'>    } finally {
</span><span class='line'>        closeQuietly(in);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>return result;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>С помощью ClassLoader'a загружается файл с именем класса, переданного в аргументе <code>service</code>. На данный момент в качестве service используется класс <code>MockMaker</code>. Файл ищется в папке с именем "mockito-extensions". В файле указываются полные имена классов - один класс на строчку. Далее эти классы загружаются и создаются их объекты. Несмотря на возможность загрузить несколько <code>MockMaker'ов</code>, будет применен только первый найденный. Если пользовательских классов нет, то загружается <code>MockMaker</code> по умолчанию <code>org.mockito.internal.creation.CglibMockMaker</code>.</p>




<blockquote>
Создание прокси классов, а mock объекты фактически ими и являются, по умолчанию обеспечивается библиотекой <a href="http://cglib.sourceforge.net/">CGLib</a>. Исходники этой библиотеки включены в проект, чтобы не заморачиваться с версией проекта и перепаковкой исходников. Конечно, <em>Maven</em> облегчил бы задачу и структура проекта стала бы яснее, но что сделано, то сделано. Разработчики не модифицируют эти исходники и в целом это запрещается. <em>CGLib</em> - библиотека, позволяющая создавать, расширять классы и интерфейсы в runtime'e.
</blockquote>




<p>Внутри <code>MockMaker</code>'a обработчик вызова стаббированных методов - <code>MockHandler</code> оборачивается внутрь класса <code>MethodInterceptorFilter</code>, реализующего интерфейс <code>MethodInterceptor</code>, который является частью <em>CGLib</em> библиотеки.</p>




<p>Как ни странно, логика создания объектов с использованием <em>CGLib</em> размыта и описана в неком утилитарном классе <code>org.mockito.internal.creation.jmock.ClassImposterizer</code>, который уже использовался при проверке настроек mock'объекта. Этот класс позаимствован из библиотеки <a href="http://www.jmock.org/">jMock</a>.</p>




<blockquote>
#Thanks to jMock guys for this handy class that wraps all the cglib magic.
</blockquote>




<p>Кстати, это не единственный класс в <em>Mockito</em> с похожим комментарием.</p>




<p>Этот класс вносит разнородность в <em>Mockito</em>, что очень некрасиво. Например, для создания экземпляров классов используется библиотека <a href="http://code.google.com/p/objenesis/">objenesis</a>. В <em>Mockito</em> же эта процедура выполняется напрямую, с помощью рефлексии.</p>




<p>В первую очередь устанавливается видимость конструкторов, класс для которого создается Mock объект. Это мы уже проходили. Решается парой методов рефлексии. Далее создается класс proxy объекта. Эта работа выполняется с помощью <em>CGLib</em> класса <code>Enhancer</code>. Этот класс конструирует класс для будущего proxy по параметрам, которые мы в него передали.</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private Class&lt;?> createProxyClass(Class&lt;?> mockedType, Class&lt;?>...interfaces) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if (mockedType == Object.class) {
</span><span class='line'>    mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>Enhancer enhancer = new Enhancer() {
</span><span class='line'>    @Override
</span><span class='line'>    @SuppressWarnings("unchecked")
</span><span class='line'>    protected void filterConstructors(Class sc, List constructors) {
</span><span class='line'>        // Don't filter
</span><span class='line'>    }
</span><span class='line'>};
</span><span class='line'>enhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(mockedType));
</span><span class='line'>enhancer.setUseFactory(true);
</span><span class='line'>if (mockedType.isInterface()) {
</span><span class='line'>    enhancer.setSuperclass(Object.class);
</span><span class='line'>    enhancer.setInterfaces(prepend(mockedType, interfaces));
</span><span class='line'>} else {
</span><span class='line'>    enhancer.setSuperclass(mockedType);
</span><span class='line'>    enhancer.setInterfaces(interfaces);
</span><span class='line'>}
</span><span class='line'>enhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});
</span><span class='line'>try {
</span><span class='line'>    return enhancer.createClass(); 
</span><span class='line'>} catch (CodeGenerationException e) {
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Я опустил некоторые моменты по управлению секьюрностью классов и обработки исключения. Они незначительны.</p>




<p>Для начала решаем проблему с багом <em>CGLib</em>, который отказывается обрабатывать класс <code>Object</code>, так как где-то, видимо, завязывается на родителе класса. Т.е. если тип mock объекта - <code>Object</code>, то мы создаем пустой объект <code>ClassWithSuperclassToWorkAroundCglibBug</code>, с которым дальше работаем. Затем создаем объект <code>Enhancer'a</code>, и ему передаются classloader'ы классов будущих mock'ов, обернутых во внутренний класс <em>CGLib</em> для работы со всеми найденными classloader'ами как с одним. Класс, помимо прочего, будет реализовывать интерфейс <code>Factory</code>, который определяет методы установки обработчиков вызовов методов и инстанцирования этих объектов. Это внутренняя особенность <em>CGLib</em>. Далее указываем <code>Enhancer'у</code> типы классов и интерфейсов, которые он должен будет унаследовать, и типы обработчиков-перехватчиков методов классов. В данном случае это стандартные классы <code>MethodInterceptor</code>, который позволяет определять обработчики, и <code>NoOp</code>, который передает управление методам объекта напрямую - нужно для <code>Spy</code> моков.</p>




<p>Следующим шагом создается объект прокси:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private Object createProxy(Class&lt;?> proxyClass, final MethodInterceptor interceptor) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>Factory proxy = (Factory) objenesis.newInstance(proxyClass);
</span><span class='line'>proxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });
</span><span class='line'>return proxy;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Как видно, objensis намного упрощает создание объектов. У разработчиков, видимо, не доходят руки, чтобы переписать старый код с использованием этой библиотеки. В качестве обработчиков событий указываем созданный ранее InternalMockHandler и пустую реализацию интерфейса NoOp.</p>




<p>Теперь остается только оповестить все компоненты системы о событии создания мока:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mockingProgress.mockingStarted(mock, typeToMock);</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>и вернуть его в класс-тест.</p>




<p>Хочу заметить, что в коде немало хардкода. Немало мест, где метод принимает параметры по общему интерфейсу, а внутри метода проверяется объект на соответствие определенному типу, который реализует этот интерфейс:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private InternalMockHandler cast(MockHandler handler) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if (!(handler instanceof InternalMockHandler)) {
</span><span class='line'>    throw new MockitoException("At the moment you cannot provide own implementations of MockHandler." +
</span><span class='line'>            "\nPlease see the javadocs for the MockMaker interface.");
</span><span class='line'>}
</span><span class='line'>return (InternalMockHandler) handler;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Но стоит отдать разработчикам должное за заботу о пользователях - расширяя проект, они стараются не менять старую часть API. Обидно было бы переписывать кучу тестов при переходе на новую версию <em>Mockito</em>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mockito: @InjectMocks]]></title>
    <link href="http://knowlix.github.io/blog/2012/06/29/mockito-inject-mocks/"/>
    <updated>2012-06-29T00:33:00+04:00</updated>
    <id>http://knowlix.github.io/blog/2012/06/29/mockito-inject-mocks</id>
    <content type="html"><![CDATA[<p>Процесс внедрения mock'ов разделен на несколько этапов:</p>




<ol class="enum">
    <li>Поиск полей, отмеченных аннотацией <code>@InjectMocks</code></li>
    <li>Поиск мок объектов в тесте</li>
    <li>Внедрение найденных моков в поля, помеченные аннотацией <code>@InjectMocks</code></li>
</ol>




<!--more-->


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Set&lt;Field> mockDependentFields = new HashSet&lt;Field>();
</span><span class='line'>Set&lt;Object> mocks = newMockSafeHashSet();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>while (clazz != Object.class) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>new InjectMocksScanner(clazz).addTo(mockDependentFields);
</span><span class='line'>new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);
</span><span class='line'>clazz = clazz.getSuperclass();
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>В <a href="https://code.google.com/p/mockito/" rel="nofollow">Mockito</a> используется собственный утилитарный класс <code>Sets</code>, с помощью которого создаются внутренние реализации множеств. В данном случае заимпортирован один из его статичных методов newMockSafeHashSet. Метод создает реализацию под названием <code>org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet</code>. Создана отдельная реализация <code>Set</code> интерфейса лишь для того, чтобы скрыть особенность реализации моков. А именно, есть некоторая проблема в стаббинге методов <code>Object.equals</code> и <code>Object.hashCode</code>, и они могут выкидывать <code>NullPointerException</code>. Истинную причину выясним при разборе процесса subbing'а. При работе в коллекциях эти методы интенсивно используются при поиске и добавлении элементов, поэтому мы оборачиваем мок объект в этот wrapper, который использует свои методы <code>equals</code> и <code>hashCode</code>. Оборачивание моков происходит в момент добавления элементов в множество.</p>




<p>Вернемся к примеру. В множество mocks у нас будут добавлены все найденные mock-объекты. Стоит заметить, что в Mockito много переменных модифицируются, будучи переданными через аргументы. Так и в данном случае коллекции наполяются именно так. Immutability здесь явно не хватает. <code>org.mockito.internal.configuration.injection.scanner.InjectMocksScanner</code> реализует алгоритм поиска полей, отмеченных аннотацией <code>@InjectMocks</code>. Основные два метода класса:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private Set&lt;Field> scan() {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>Set&lt;Field&gt; mockDependentFields = new HashSet&lt;Field&gt;();
</span><span class='line'>Field[] fields = clazz.getDeclaredFields();
</span><span class='line'>for (Field field : fields) {
</span><span class='line'>    if (null != field.getAnnotation(InjectMocks.class)) {
</span><span class='line'>        assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);
</span><span class='line'>        mockDependentFields.add(field);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>return mockDependentFields;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>void assertNoAnnotations(final Field field, final Class... annotations) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>for (Class annotation : annotations) {
</span><span class='line'>    if (field.isAnnotationPresent(annotation)) {
</span><span class='line'>        new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMocks.class.getSimpleName());
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Именно результат метода scan и добавляет в наше множество. В цикле пробегаем по полям класса-теста, проверяем есть ли у поля аннотация <code>@InjectMocks</code>. Стоит отметить, что используются системные java классы полей и классов. Пока, по-моему, ничего сверхъестественного. Далее, если метод аннотирован, то проверяем не аннотирован ли он еще и стаббирующими аннотациями (<code>@Mock</code>, <code>@Captor</code>), т.к. это противоречит логике и не может быть допущено. В случае нарушения правил выбрасывается <code>RuntimeException</code>. Если все в порядке, то мы можем добавить поле в наше множество.</p>




<p><code>org.mockito.internal.configuration.injection.scanner.MockScanner</code> реализуется второй этап алгоритма внедрения моков - поиск мок объектов в тесте. Основные методы класса:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private Set&lt;Object> scan() {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>Set&lt;Object&gt; mocks = newMockSafeHashSet();
</span><span class='line'>for (Field field : clazz.getDeclaredFields()) {
</span><span class='line'>    // mock or spies only
</span><span class='line'>    FieldReader fieldReader = new FieldReader(instance, field);
</span><span class='line'>
</span><span class='line'>    Object mockInstance = preparedMock(fieldReader.read(), field);
</span><span class='line'>    if (mockInstance != null) {
</span><span class='line'>        mocks.add(mockInstance);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>return mocks;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>private Object preparedMock(Object instance, Field field) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if (isAnnotatedByMockOrSpy(field)) {
</span><span class='line'>    return instance;
</span><span class='line'>} else if (isMockOrSpy(instance)) {
</span><span class='line'>    mockUtil.maybeRedefineMockName(instance, field.getName());
</span><span class='line'>    return instance;
</span><span class='line'>}
</span><span class='line'>return null;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>private boolean isAnnotatedByMockOrSpy(Field field) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>return null != field.getAnnotation(Spy.class)
</span><span class='line'>        || null != field.getAnnotation(Mock.class)
</span><span class='line'>        || null != field.getAnnotation(MockitoAnnotations.Mock.class);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>private boolean isMockOrSpy(Object instance) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>return mockUtil.isMock(instance)
</span><span class='line'>        || mockUtil.isSpy(instance);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Класс выполнен в стиле <code>InjectMocksScanner</code>, хотя общего интерфейса у классов нет. Но это не страшно, т.к. выполняют они сугубо утилитарные функции. Результат метода scan помещается в множество найденных мок объектов для внедрения. За чтение значений полей класса из конкретных объектов отвечает FieldReader. Основная строчка его метода read:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>return field.get(target)</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p>В методе <code>MockScanner#preparedMock</code> определяется, является ли полученный из поля объект mock'ом. Определяется он по наличию в поле аннотаций <code>@Mock</code> или <code>@Spy</code>. Если аннотаций нет, то есть вероятность, что объекты были стаббированы вручную. Это проверяется в методе <code>MockScanner#isMockOrSpy</code>. В случае, если объект все-таки является <em>Mock</em> объектом, то возможно требуется его переименование. Необходимость такого решения возможно выяснится позднее, когда мы разберем процесс создания <em>Mock</em> объектов. На данный момент это выглядит каким то костылем.</p>

<p><p>Осталось дело за малым - внедрить мок-объекты. Отправная точка <code>org.mockito.internal.configuration#DefaultInjectionEngine</code> - объект, который инициализирует обработчиков-внедренцев. И запускает процесс инжектирования. Внедрением занимаются <code>org.mockito.internal.configuration.injection.MockInjectionStrategy</code> объекты. На данный момент моки инжектируются через конструктор (<code>ConstructorInjection</code>), поля класса и сеттеры (<code>PropertyAndSetterInjection</code>).</p></p>

<p><blockquote></p>

<pre><code>Поле, помеченное аннотацией @InjectMocks, может быть помечено ещё и аннотацией @Spy, что заставляет, в случае неуспешного внедрения моков в объект, создавать из него Spy-объект. Хотя в целом JavaDoc полный, этот факт скрыт от глаз пользователей.
</code></pre>

<p></blockquote></p>

<p><p>Для обработки <code>@Spy</code> аннотации, если не получилось создать объект, в который внедрялись моки, используется <code>SpyOnInjectedFieldsHandler</code>. Основной метод <code>DefaultInjectionEngine</code> - <code>#injectMocksOnFields</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void injectMocksOnFields(Set&lt;Field> needingInjection, Set&lt;Object> mocks, Object testClassInstance) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>MockInjection.onFields(needingInjection, testClassInstance)
</span><span class='line'>        .withMocks(mocks)
</span><span class='line'>        .tryConstructorInjection()
</span><span class='line'>        .tryPropertyOrFieldInjection()
</span><span class='line'>        .handleSpyAnnotation()
</span><span class='line'>        .apply();
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p>Как видно, объект-конфигуратор процесса внедрения - <code>org.mockito.internal.configuration.injection.MockInjection</code>. Он определяет внутри себя реализации той или иной стратегии. Поэтому его методы <code>tryConstructorInjection</code>, <code>tryPropertyOrFieldInjection</code> и <code>handleSpyAnnotation</code> возвращают именно те классы стратегий, которые мы рассмотрели выше. Метод <code>onFields</code> возвращает объект <code>OngoingMockInjection</code> - внутренний класс класса <code>MockInjection</code>. Его тип нас не должен интересовать, т.к. проектировался этот объект для использования здесь и сейчас в виде Builder'а, что обеспечивается возвращением из каждого его метода ссылки на самого себя. Этот объект-builder сохраняет в конструкторе поля с аннотацией <code>@InjectMocks</code>. Далее метод withMocks сохраняет список mock объектов. Странный подход к инициализации базовых данных. Практичнее было бы внести сохранение списка mock объектов в конструктор, т.к. инжектирование без них смысла не имеет. А так как порядок выполнения Builder методов не регулируется, то можно пропустить этот метод. Далее 3'мя следующими методами объявляем стратегии инжектирования, которые хотим использовать. Стратегии инжектирования образуют цепочку стратегий по примеру паттерна Composite. Вызывая основной метод первого из них, он обрабатывает основную логику, затем вызывается аналогичный метод связанного с ним объекта-внедренца. И так до последнего. На практике это реализуется следующим образом:</p></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private MockInjectionStrategy injectionStrategies = MockInjectionStrategy.nop();</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p>В <code>OngoingMockInjection</code> создается поле с пустой стратегией обработчиком, где nop() - фабричный метод возвращающий пустую реализацию:</p></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static final MockInjectionStrategy nop() {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>return new MockInjectionStrategy() {
</span><span class='line'>    protected boolean processInjection(Field field, Object fieldOwner, Set&lt;Object&gt; mockCandidates) {
</span><span class='line'>        return false;
</span><span class='line'>    }
</span><span class='line'>};
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p><code>processInjection</code> - основной абстрактный метод MockInjectionStrategy, в котором определяется логика внедрения моков. Методы добавления следующего в цепочке обработчика выглядят следующим образом:</p></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public OngoingMockInjection tryConstructorInjection() {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>injectionStrategies.thenTry(new ConstructorInjection());
</span><span class='line'>return this;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>public OngoingMockInjection tryPropertyOrFieldInjection() {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>injectionStrategies.thenTry(new PropertyAndSetterInjection());
</span><span class='line'>return this;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p>Где метод <code>thenTry</code> передает добавляемый объект следующему в цепочке объекту, пока не будет достигнут последний объект в цепочке. Он то и примет к себе новое звено:</p></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public MockInjectionStrategy thenTry(MockInjectionStrategy strategy) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if(nextStrategy != null) {
</span><span class='line'>    nextStrategy.thenTry(strategy);
</span><span class='line'>} else {
</span><span class='line'>    nextStrategy = strategy;
</span><span class='line'>}
</span><span class='line'>return strategy;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p>Метод <code>OngoingMockInjection#apply</code>, который завершает цепочку методов Builder'а, выполняет метод injectionStrategies.process, первого из цепочки стратегий обработки объекта для каждого поля, аннотированного <code>@InjectMocks</code>:</p></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public boolean process(Field onField, Object fieldOwnedBy, Set&lt;Object> mockCandidates) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if(processInjection(onField, fieldOwnedBy, mockCandidates)) {
</span><span class='line'>    return true;
</span><span class='line'>}
</span><span class='line'>return relayProcessToNextStrategy(onField, fieldOwnedBy, mockCandidates);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p>Где осуществляется вызов метода с логикой обработки, а затем в методе relayProcessToNextStrategy передается управление следующему объекту в цепи.</p></p>

<p><p>Метод <code>OngoingMockInjection#handleSpyAnnotation</code> прикрепляет финальный обработчик <code>@Spy</code> аннотаций в другой <code>MockInjectionStrategy#nop()</code>, который также вызывается для каждого поля в методе apply после вызова цепочки стратегий внедрения.</p></p>

<p><p>Рассмотрим алгоритм внедрения через конструктор:</p></p>

<p><p>ConstructorInjection определяет внутри себя реализацию ConstructorArgumentResolver'а, где определяется алгоритм получения mock'ов из найденного заранее множества, которые могут быть приравнены к типам аргументов конструктора.</p></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Object[] resolveTypeInstances(Class&lt;?>... argTypes) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>List&lt;Object&gt; argumentInstances = new ArrayList&lt;Object&gt;(argTypes.length);
</span><span class='line'>for (Class&lt;?&gt; argType : argTypes) {
</span><span class='line'>    argumentInstances.add(objectThatIsAssignableFrom(argType));
</span><span class='line'>}
</span><span class='line'>return argumentInstances.toArray();
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p>Где метод objectThatIsAssignableFrom перебирает множество mock объектов и ищет первое из них, которое удовлетворяет условию:</p></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>argType.isAssignableFrom(mock.getClass())</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p>Выбор конструктора, определение его параметров и создание нового экземпляра класса для поля, аннотированного <code>@InjectMocks</code>, осуществляется в классе <code>org.mockito.internal.util.reflection.FieldInitializer</code>. Внутри определены две реализации <code>ConstructorInstantiator</code> для обработки - конструктор с параметрами и без параметров. В ConstructorInjection используется <code>ParameterizedConstructorInstantiator</code>, так как внедрение mock объектов в конструктор без параметров смысла не имеет. Соответственно, первое что делается - это проверка - не создан ли объект в целевом поле.</p></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private FieldInitializationReport acquireFieldInstance() throws IllegalAccessException {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>Object fieldInstance = field.get(fieldOwner);
</span><span class='line'>if(fieldInstance != null) {
</span><span class='line'>    return new FieldInitializationReport(fieldInstance, false, false);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>return instantiator.instantiate();
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p>Значение объекта получается уже знакомым способом через метод get. Если объект уже в поле создан, то нет смысла идти дальше - возвращаем результат о неуспешном создании объекта. <code>FieldInitializationReport</code> - класс с данными результатов создания класса. <code>instantiator</code> - это и есть один из экземпляров <code>ConstructorInstantiator</code>. По методу <code>instantiate</code> выполняется основная логика поиска соответствующего конструктора и создания самого объекта. Основное содержание метода:</p></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>constructor = biggestConstructor(field.getType());
</span><span class='line'>changer.enableAccess(constructor);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>final Object[] args = argResolver.resolveTypeInstances(constructor.getParameterTypes());
</span><span class='line'>Object newFieldInstance = constructor.newInstance(args);
</span><span class='line'>new FieldSetter(testClass, field).set(newFieldInstance);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>return new FieldInitializationReport(field.get(testClass), false, true);</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p>С помощью метода <code>biggestConstructor</code> (кстати, неудачное название, т.к. не отражает действия) определяется конструктор с наибольшим количеством параметров. Реализация тривиальна.</p></p>

<p><p>С помощью метода changer.enableAccess изменяем доступность конструктора:</p></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>constructor.setAccessible(true);</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p>При этом сохраняем старое значение accesible, чтобы вернуть его в конце метода в блоке finally:</p></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>finally {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if(constructor != null) {
</span><span class='line'>    changer.safelyDisableAccess(constructor);
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><p><code>argResolver</code> - реализация <code>ConstructorArgumentResolver</code>, которая определяется внутри <code>ConstructorInjection</code> (о нем мы говорили выше). С помощью него мы получаем массив mock объектов в нужном нам порядке и создаем с помощью них новый экземпляр класса целевого поля. <code>FieldSetter</code> - противоположность <code>FieldReader'а</code>. Вставляет значение в поле, при этом также меняя видимость поля. В конце возвращается <code>FieldInitializationReport</code> с отчетом об успешном создании объекта. В дальнейшем из этого объекта получится флаг <code>fieldWasInitializedUsingContructorArgs</code>,и если он равен <code>true</code>, то вызов следующих обработчиков в цепочке прекращается.</p></p>

<p><p>Остальные обработчики работают по такому же принципу. Так что нет особого смысла их детально рассматривать.</p></p>

<p><p>На этом рассмотрение аннотаций заканчивается. В комментариях отвечу на любые вопросы.</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mockito: Обработка аннотаций]]></title>
    <link href="http://knowlix.github.io/blog/2012/06/26/mockito-init-mocks/"/>
    <updated>2012-06-26T21:33:00+04:00</updated>
    <id>http://knowlix.github.io/blog/2012/06/26/mockito-init-mocks</id>
    <content type="html"><![CDATA[<p>Как говорилось ранее, метод <code>MockitoAnnotations#initMocks</code> инициализирует объекты, аннотированные одной из ключевых аннотаций (<code>@Spy</code>, <code>@Mock</code>, <code>@Captor</code>, <code>@InjectMocks</code>). Сегодня мы увидим как обрабатываются аннотации. Архитектура должна быть гибкой, чтобы позволить удобно добавлять новые аннотации.</p>




<!--more-->




<p>В метод передается единственный аргумент - ссылка на объект теста. Именно по полям этого объекта будет произведен поиск аннотаций. Т.к. объект <code>MockitoAnnotations</code> является частью внешнего API <a href="https://code.google.com/p/mockito/" rel="nofollow">Mockito</a>, то любые аргументы должны быть проверены на <code>null</code>, что и сделано. В случае обнаружения <code>null</code> выкидывается <code>MockitoException</code>.</p>




<blockquote>
    В <em>Mockito</em> все исключения собраны в утилитарном объекте org.mockito.exceptions.Reporter, каждый метод которого выкидывает определенное исключение. Вообще сомнительное решение, но в данном случае (в методе initMocks этот подход проигнорирован и исключение выбрасывается напрямую).
</blockquote>




<p>Далее в методе инициализируется объект, реализующий интерфейс <code>org.mockito.configuration.AnnotationEngine</code>. Этот объект непосредственно ищет аннотации и вызывает создание соответствующего объекта. Различные реализации AnnotationEngine отвечают за разные группы аннотаций и, соответственно, подход к обработке этих групп отличается. </p>




<p>Реализация <code>AnnotationEngine</code> определена в <code>org.mockito.internal.configuration.GlobalConfiguration</code>. Это объект, хранящий базовую конфигурацию системы. Переопределить настройки можно только создав свой собственный объект, реализующий интерфейс <code>org.mockito.internal.configuration.IMockitoConfiguration</code>. <em>Mockito</em> подцепит его автоматически, если назвать и расположить его так, чтобы его наименование соответствовало наименованию, которое хранится в публичном поле <code>org.mockito.internal.configuration.ClassPathLoader#MOCKITO_CONFIGURATION_CLASS_NAME</code>. На данный момент это "org.mockito.configuration.MockitoConfiguration". За загрузку custom'ной конфигурации отвечает класс <code>ClassPathLoader</code>, который загружает её по захардкоденному наименованию. Вот так выглядит метод <code>GlobalConfiguration#createConfig</code>:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private IMockitoConfiguration createConfig() {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration();
</span><span class='line'>IMockitoConfiguration config = new ClassPathLoader().loadConfiguration();
</span><span class='line'>if (config != null) {
</span><span class='line'>    return config;
</span><span class='line'>} else {
</span><span class='line'>    return defaultConfiguration;
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Таким образом, в случае отсутствия внешней конфигурации загружается конфигурация по умолчанию. Стоит отметить, что <code>GlobalConfiguration</code> является singletone'ом для объектов одного потока, т.к. реализация конфигурации хранится в <code>ThreadLocal</code> переменной класса <code>GlobalConfiguration</code>:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private static ThreadLocal&lt;IMockitoConfiguration> globalConfiguration = new ThreadLocal&lt;IMockitoConfiguration>();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>public GlobalConfiguration() {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if (globalConfiguration.get() == null) {
</span><span class='line'>    globalConfiguration.set(createConfig());
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<blockquote>
    В <em>Mockito</em> способ использования единого экземпляра объекта с помощью ThreadLocal переменных очень распространен и используется повсеместно. Так как тесты, в подавляющем своем большинстве, запускаются в одном потоке, то этот способ работает.
</blockquote>




<p>В <code>DefaultMockitoConfiguration#getAnnotationEngine</code> возвращается <code>org.mockito.internal.configuration.InjectingAnnotationEngine</code> - реализация <code>AnnotationEngine</code>, обрабатывающая стаббирующие аннотации (<code>@Spy</code>, <code>@Mock</code>, <code>@Captor</code>) и внедряющая их объекты в <code>@InjectMocks</code> объект. </p>




<blockquote>
InjectingAnnotationEngine - делегат. Дело в том, что аннотации добавлялись постепенно. С появлением аннотации InjectMocks появилась необходимость работать с проинициализированными объектами. Разработчики решили использовать в такой ситуации создающие AnnotationEngine внутри инжектируемого. Таким образом, инжектирующий AnnotationEngine делегирует создающим AnnotationEngine обязанность по созданию объектов, а сам затем занимается уже внедрением этих объектов.
</blockquote>




<p>Таким образом, в <code>InjectingAnnotationEngine</code> присутствуют два <code>AnnotationEngine</code>, которым делегируется обработка старых аннотаций, а именно:</p>




<ol class="enum">
    <li><code>DefaultAnnotationEngine</code> обрабатывает аннотации <code>@Mock</code> и <code>@Captor</code></li>
    <li><code>SpyAnnotationEngine</code> обрабатывает <code>@Spy</code> аннотации</li>
</ol>




<p>Сам же класс <code>InjectingAnnotationEngine</code> обрабатывает аннотации <code>@InjectMocks</code>.</p>




<p>Основной метод <code>InjectingAnnotationEngine#process</code> сначала вызывает инициализацию стаббируемых объектов, делегируя эти функции другим реализациям, затем вторым шагом внедряет эти объекты в поле, аннотированное как <code>@InjectMocks</code>:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private void processIndependentAnnotations(final Class&lt;?> clazz, final Object testInstance) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>Class&lt;?&gt; classContext = clazz;
</span><span class='line'>while (classContext != Object.class) {
</span><span class='line'>    //this will create @Mocks, @Captors, etc:
</span><span class='line'>    delegate.process(classContext, testInstance);
</span><span class='line'>    //this will create @Spies:
</span><span class='line'>    spyAnnotationEngine.process(classContext, testInstance);
</span><span class='line'>
</span><span class='line'>    classContext = classContext.getSuperclass();
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Цикл while обходит все родительские классы класса-теста, чтобы проинициализировать и их аннотации. Затем вызываются последовательно методы <code>DefaultAnnotationEngine#process</code> и <code>SpyAnnotationEngine#process</code>. В них передается ссылка на класс объекта теста и на объект теста. Реализации этих методов достаточно тривиальны и сводятся к обходу полей класса, полученных с помощью метода <code>clazz.getDeclaredFields()</code> и затем для каждого поля обходится список аннотаций, полученных методом <code>field.getAnnotations()</code>. <code>DefaultAnnotationEngine#process</code> позволяет добавлять обработчики аннотаций. </p>




<p>Обработчик аннотаций реализует интерфейс <code>FieldAnnotationProcessor&lt;A&gt;</code>, где под типом параметра A подставляется тип аннотации, например <code>Mock</code>. Список поддерживаемых процессоров аннотаций хранится в Map'е по типу аннотации и заполняется в конструкторе <code>DefaultAnnotationEngine</code>. <code>FieldAnnotationProcessor#process</code> вызывает создание соответствующего объекта, как это делается пользователями библиотеки без использования аннотаций, т.е. с помощью вызова статических методов класса <code>Mockito</code> или <code>ArgumentCaptor</code>. <code>SpyAnnotationEngine#process</code> реализует логику процессорa аннотаций внутри себя, т.к. создан для обработки только одной аннотации - <code>@Spy</code>. Непонятно почему разработчики вынесли обработку этой аннотации в отдельный AnnotationEngine, а не добавили ещё один <code>FieldAnnotationProcessor</code>.</p>




<p>Процесс внедрения mock-объектов в аннотированное <code>@InjectMocks</code> поле немного сложнее. Его мы рассмотрим отдельно.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mockito: Использование аннотаций]]></title>
    <link href="http://knowlix.github.io/blog/2012/06/25/mockito-annotations/"/>
    <updated>2012-06-25T15:03:00+04:00</updated>
    <id>http://knowlix.github.io/blog/2012/06/25/mockito-annotations</id>
    <content type="html"><![CDATA[<p><a href="https://code.google.com/p/mockito/" rel="nofollow">Mockito</a> поддерживает аннотации с 0.9'ой версии. В той версии была введена аннотация <code>@Mock</code>, которая позволяет создавать mock-объекты. Далее были добавлены и другие аннотации:</p>




<ul class="enum">
    <li><code>@Spy</code> создает spy-объекты</li>
    <li><code>@Captor</code> создает экземпляр ArgumentCapture</li>
    <li><code>@InjectMocks</code> внедряет mock- и spy- объекты в аннотированный объект</li>
    <li><code>@Incubating</code> определяет недавно добавленный класс, с возможностью его изменения.</li>
</ul>




<!--more-->


<p>Обработка аннотаций начинается с класса <code>org.mockito.MockitoAnnotaions</code>. В период существования только одной анотации <code>@Mock</code>, она была объявлена внутри этого класса, о чем свидетельствует deprecated аннотация. Позднее аннотации были вынесены в отдельные файлы.</p>

<p>Запуск обработки аннотаций осуществляется вызовом метода <code>MockitoAnnotaions#initMocks</code>. Разработчики предоставили нам два пути по работе с этим классом:</p>

<ol class="enum">
    <li>Вручную, передав в качестве параметра ссылку на объект теста: <code>MockitoAnnotations.initMocks(this)</code></li>
    <li>С помощью junit runner'a: <code>@RunWith(MockitoJUnitRunner.class)</code></li>
</ol>


<p>Работа Runner'a организована следующим образом. Наружу из библиотеки выглядывает объект, реализующий интерфейс <code>org.junit.runner.Runner</code> для использования непосредственно в <em>JUnit</em>. В его конструкторе с помощью <code>org.mockito.internal.runners.RunnerFactory</code> создается экземпляр внутренней реализации Runner'a.</p>

<blockquote>
    RunnerFactory инкапсулирует логику создания новых экземпляров Runner'ов в отдельный объект org.mockito.internal.runners.util.RunnerProvider. Такое решение основано на  странном способе создания Runner'ов с помощью рефлексии. Об этом ниже.
</blockquote>


<p> Внутренняя реализация Runner'a (назовем его Mockito Runner) определяется версией <em>JUnit</em>, т.к. начиная с версии 4.5 основной реализацией JUnit Runner'a является класс <code>org.junit.runners.BlockJUnit4ClassRunner</code>. Соответственно, версия JUnit определяется наличием класса в classpath'е проекта:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>Class.forName("org.junit.runners.BlockJUnit4ClassRunner");
</span><span class='line'>hasJUnit45OrHigher = true;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>} catch (Throwable t) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>hasJUnit45OrHigher = false;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>А создаются эти реализации с помощью рефлексии по имени класса.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (runnerProvider.isJUnit45OrHigherAvailable()) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>return runnerProvider.newInstance("org.mockito.internal.runners.JUnit45AndHigherRunnerImpl", klass);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>} else {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>return runnerProvider.newInstance("org.mockito.internal.runners.JUnit44RunnerImpl", klass);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Необходимость такого решения на данный момент выясняется у разработчиков <em>Mockito</em>.</p>

<p>Реализации Mockito Runner в пакете <code>org.mockito.internal.runners</code>:</p>

<ol class="enum">
    <li><code>JUnit44RunnerImpl</code> использует <code>org.junit.internal.runners.JUnit4ClassRunner</code></li>
    <li><code>JUnit45AndHigherRunnerImpl</code> использует <code>org.junit.runners.BlockJUnit4ClassRunner</code></li>
</ol>


<p>Mockito Runner в конструкторе создает анонимный класс, унаследованный от соответствующего JUnit Runner'a, где вызывается <code>MockitoAnnotations#initMocks</code>.</p>

<blockquote>
    При использовании runner'ов для инициализации аннотаций Mockito автоматически добавляет свой org.junit.runner.notification.RunListener - FrameworkUsageValidator. Этот валидатор подписывается на событие testFinished и вызывает org.mockito.Mockito#validateMockitoUsage для самодиагностики.
</blockquote>


<p>В комплекте с MockitoJUnitRunner идет еще одна реализация Runner'a - ConsoleSpammingMockitoJUnitRunner. От первого она отличается тем, что добавляет свой RunListener, который по событию testFailure логирует все сообщения. На данный момент логируются события создания mock-объектов. За коллекционирование сообщений системы отвечает класс <code>org.mockito.internal.debugging.WarningsCollector</code>, который по глобальному событию создания mock'ов логирует что и как создалось.</p>

<p>Система событий в Mockito реализована своеобразно. Принцип работы отчасти позаимствован у JUnit, т.е. есть класс с методами событий. Переопределяя некоторые из них мы описываем обработчик соответствующего события. Но разработчики mockito пошли немного другим путем. Для каждого события создается отдельный интерфейс listener'a, который расширяет общий для всех listener'ов интерфейс <code>MockingProgressListener</code>. Самое интересное это то, что <code>MockingProgressListener</code> - это пустой интерфейс-маркер, а в интерфейс конкретного обработчика добавляются методы совершенно произвольной сигнатуры. На практике это выглядит следующим образом. Есть интерфейс обработчика события создания mock-объектов:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface MockingStartedListener extends MockingProgressListener {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>void mockingStarted(Object mock, Class classToMock);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>И есть непосредственно обработчик <code>org.mockito.internal.listeners.CollectCreatedMocks</code>, реализующий этот интерфейс.</p>

<p>В Mockito есть центральный класс, который реализует интерфейс MockingProgress. Этот класс хранит состояние процесса тестирования с помощью <em>Mockito</em>. В момент установки состояния старта создания mock-объекта он оповещает обработчик соответствующего события следующим образом:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (listener != null &amp;&amp; listener instanceof MockingStartedListener) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>((MockingStartedListener) listener).mockingStarted(mock, classToMock);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>А если ещё принять во внимание, что объект <code>MockingProgress</code> в большинстве случаев будет синглтоном, он принимает только один обработчик и метод setListener вынесен в его интерфейс, то становится страшно (надеюсь разработчики Mockito прокомментируют этот момент).</p>
]]></content>
  </entry>
  
</feed>
