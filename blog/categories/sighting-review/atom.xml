<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Sighting review | CodeInsider]]></title>
  <link href="http://knowlix.github.io/blog/categories/sighting-review/atom.xml" rel="self"/>
  <link href="http://knowlix.github.io/"/>
  <updated>2013-09-22T18:40:47+04:00</updated>
  <id>http://knowlix.github.io/</id>
  <author>
    <name><![CDATA[Code insiders]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Прицельный обзор: OAuth вне браузера через Scribe]]></title>
    <link href="http://knowlix.github.io/blog/2013/03/03/scribe-oauth-library/"/>
    <updated>2013-03-03T22:53:00+04:00</updated>
    <id>http://knowlix.github.io/blog/2013/03/03/scribe-oauth-library</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/fernandezpablo85/scribe-java">Scribe</a> - простая java библиотека, позволяющая проводить авторизацию на сервисах по OAuth протоколу. Библиотека интересна тем, что рекомендуется <a href="https://dev.twitter.com/docs/twitter-libraries#java">twitter&#8217;ом</a> и <a href="https://developer.linkedin.com/documents/libraries-and-tools">linkedin&#8217;ом</a> для работы с их реализациями OAuth аутентификации.</p>




<!--more-->




<p>Библиотека хостится на Github’е, а в качестве CI используется <em>Travis-CI</em>. Кто не знает, <a href="https://github.com/travis-ci/travis-ci">Travis-CI</a> - распределенная система сборки проекта, тесно интегрирующаяся с Github репозиторием.</p>




<p>Build Tool - Maven. Проект реализован в одном модуле.</p>




<p>Проект ведет рядовой разработчик аутсорсинговой компании в южной америке, которая занимается некоторыми задачами разработки LinkedIn’а.</p>




<p>Библиотека удобно оборачивает OAuth протокол для авторизации из java приложения, предлагая весомый набор предустановленных OAuth провайдеров, таких как Twitter, Google, Yahoo. В комплекте идет пакет examples, где показано как работать с каждым из провайдеров.</p>




<p>Все начинается с создания OAuthService объекта:</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OAuthService service = new ServiceBuilder()
</span><span class='line'>       .provider(TwitterApi.class)
</span><span class='line'>             .apiKey("6icbcAXyZx67r8uTAUM5Qw")
</span><span class='line'>             .apiSecret("SCCAdUUc6LXxiazxH3N0QfpNUvlUy84mZ2XZKiv39s")
</span><span class='line'>             .build();</span></code></pre></td></tr></table></div></figure></p>

<p>Классический Builder-подход, где задается <code>OAuthProvider</code> и данные для аутентификации. Отдельный провайдер отвечает за отдельный сервис. В данном случае - это Twitter. Провайдер ответственен за создание <code>OAuthService’а</code>, который несет в себе специфичную для конкретного сервиса информацию - url, версия OAuth и т.д.</p>




<p>Разработчик грамотно организовал дерево классов. Все провайдеры унаследованы от интерфейса <code>Api</code>, в котором описана сигнатура единственного метода <code>createService</code>. На следующем уровне этот интерфейс расширяют абстрактные классы, специфичные для разных версий OAuth (реализованы обе версии). Конкретные провайдеры наследуют класс, реализующий интерфейс <code>Api</code> с привязкой к версии OAuth протокола  и определяют внутри себя URL для доступа к сервису:</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class FacebookApi extends DefaultApi20
</span><span class='line'>{
</span><span class='line'>  private static final String AUTHORIZE_URL = "https://www.facebook.com/dialog/oauth?client_id=%s&amp;redirect_uri=%s";
</span><span class='line'>  private static final String SCOPED_AUTHORIZE_URL = AUTHORIZE_URL + "&amp;scope=%s";
</span><span class='line'>
</span><span class='line'>  @Override
</span><span class='line'>  public String getAccessTokenEndpoint()
</span><span class='line'>  {
</span><span class='line'>  return "https://graph.facebook.com/oauth/access_token";
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  @Override
</span><span class='line'>  public String getAuthorizationUrl(OAuthConfig config)
</span><span class='line'>  {
</span><span class='line'>  Preconditions.checkValidUrl(config.getCallback(), "Must provide a valid url as callback. Facebook does not support OOB");
</span><span class='line'>
</span><span class='line'>  // Append scope if present
</span><span class='line'>  if(config.hasScope())
</span><span class='line'>  {
</span><span class='line'>  return String.format(SCOPED_AUTHORIZE_URL, config.getApiKey(), OAuthEncoder.encode(config.getCallback()), OAuthEncoder.encode(config.getScope()));
</span><span class='line'>  }
</span><span class='line'>  else
</span><span class='line'>  {
</span><span class='line'>      return String.format(AUTHORIZE_URL, config.getApiKey(), OAuthEncoder.encode(config.getCallback()));
</span><span class='line'>  }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>Версия OAuth определяет реализацию <code>OAuthService</code> класса, тип запроса (GET, POST) и другие специфичные для версии вещи, например формат данных.</p>




<p>Внутри метода <code>build</code> вызывается метод <code>createService</code> провайдера. После получения <code>OAuthService’а</code> действуем согласно алгоритму работы по OAuth протоколу. Рассмотрим первую версию OAuth. Сначала получем <em>Request Token</em>:</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Token requestToken = service.getRequestToken();
</span><span class='line'>
</span><span class='line'>  public Token getRequestToken()
</span><span class='line'>  {
</span><span class='line'>  config.log("obtaining request token from " + api.getRequestTokenEndpoint());
</span><span class='line'>  OAuthRequest request = new OAuthRequest(api.getRequestTokenVerb(), api.getRequestTokenEndpoint());
</span><span class='line'>
</span><span class='line'>  config.log("setting oauth_callback to " + config.getCallback());
</span><span class='line'>  request.addOAuthParameter(OAuthConstants.CALLBACK, config.getCallback());
</span><span class='line'>  addOAuthParams(request, OAuthConstants.EMPTY_TOKEN);
</span><span class='line'>  appendSignature(request);
</span><span class='line'>
</span><span class='line'>  config.log("sending request...");
</span><span class='line'>  Response response = request.send();
</span><span class='line'>  String body = response.getBody();
</span><span class='line'>
</span><span class='line'>  config.log("response status code: " + response.getCode());
</span><span class='line'>  config.log("response body: " + body);
</span><span class='line'>  return api.getRequestTokenExtractor().extract(body);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure></p>

<p>Внутри метода формируется OAuth запрос, данные для которого берутся из Api объекта  провайдера и этот запрос отправляется на сервер. Вся работа с сетью строится на базе стандартного пакета <code>java.net</code>. Таким образом при отправке запроса(<code>request.send()</code>) сначала открывается соединение:</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private void createConnection() throws IOException
</span><span class='line'>  {
</span><span class='line'>  String completeUrl = getCompleteUrl();
</span><span class='line'>  if (connection == null)
</span><span class='line'>  {
</span><span class='line'>      System.setProperty("http.keepAlive", connectionKeepAlive ? "true" : "false");
</span><span class='line'>      connection = (HttpURLConnection) new URL(completeUrl).openConnection();
</span><span class='line'>  }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure></p>

<p>Далее добавляются <code>header'ы</code> в запрос и пишется тело сообщения:</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void addHeaders(HttpURLConnection conn)
</span><span class='line'>  {
</span><span class='line'>  for (String key : headers.keySet())
</span><span class='line'>      conn.setRequestProperty(key, headers.get(key));
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  void addBody(HttpURLConnection conn, byte[] content) throws IOException
</span><span class='line'>  {
</span><span class='line'>  conn.setRequestProperty(CONTENT_LENGTH, String.valueOf(content.length));
</span><span class='line'>
</span><span class='line'>  // Set default content type if none is set.
</span><span class='line'>  if (conn.getRequestProperty(CONTENT_TYPE) == null)
</span><span class='line'>  {
</span><span class='line'>      conn.setRequestProperty(CONTENT_TYPE, DEFAULT_CONTENT_TYPE);
</span><span class='line'>  }
</span><span class='line'>  conn.setDoOutput(true);
</span><span class='line'>  conn.getOutputStream().write(content);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure></p>

<p>В результате возвращается объект ответа(<code>Response</code>), который в конструкторе принимает данное соединение:</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Response(HttpURLConnection connection) throws IOException
</span><span class='line'>  {
</span><span class='line'>  try
</span><span class='line'>  {
</span><span class='line'>      connection.connect();
</span><span class='line'>      code = connection.getResponseCode();
</span><span class='line'>      headers = parseHeaders(connection);
</span><span class='line'>      stream = isSuccessful() ? connection.getInputStream() : connection.getErrorStream();
</span><span class='line'>  }
</span><span class='line'>  catch (UnknownHostException e)
</span><span class='line'>  {
</span><span class='line'>      throw new OAuthException("The IP address of a host could not be determined.", e);
</span><span class='line'>  }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure></p>

<p>Как видно, только в момент инстацирования Response объекта произойдет подключение к удаленному ресурсу. Это ничто иное, как размывание логики приложения. Говоря об архитектурных агрехах, можно еще упоминуть следующий факт - объект запроса использует переменные на уровне класса, которые меняются внутри его публичных методов. В итоге, состояние объекта предсказать невозможно.</p>




<p>На выходе из метода создает объект <code>Token</code>, который заполняется данными ответа. Ответ парсится с помощью регулярных выражений. Даже JSON ответ обрабатывается регулярными выражениями. Объект парсера специфичен для конкретной версии OAuth и хранится в провайдере.</p>




<p>Далее создается объект Verifier, который в конструкторе принимает код подтверждения, выдаваемый сервисом:</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Scanner in = new Scanner(System.in);</span></code></pre></td></tr></table></div></figure></p>

<p>В рамках примера используется командная строка, куда необходимо ввести этот код. Далее вызывается запрос на получение Access Token’а:</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Token accessToken = service.getAccessToken(requestToken, verifier);</span></code></pre></td></tr></table></div></figure></p>

<p>Принцип работы аналогичен отправки запроса на Request Token. Отличие лишь в данных, которые пересылаются сервису, в  url получателя и в парсере ответа, который строит объект Token’а:</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Token getAccessToken(Token requestToken, Verifier verifier)
</span><span class='line'>  {
</span><span class='line'>  config.log("obtaining access token from " + api.getAccessTokenEndpoint());
</span><span class='line'>  OAuthRequest request = new OAuthRequest(api.getAccessTokenVerb(), api.getAccessTokenEndpoint());
</span><span class='line'>  request.addOAuthParameter(OAuthConstants.TOKEN, requestToken.getToken());
</span><span class='line'>  request.addOAuthParameter(OAuthConstants.VERIFIER, verifier.getValue());
</span><span class='line'>
</span><span class='line'>  config.log("setting token to: " + requestToken + " and verifier to: " + verifier);
</span><span class='line'>  addOAuthParams(request, requestToken);
</span><span class='line'>  appendSignature(request);
</span><span class='line'>  Response response = request.send();
</span><span class='line'>  return api.getAccessTokenExtractor().extract(response.getBody());
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure></p>

<p>Далее можно осуществлять запросы к защищенному ресурсу сервиса с Token’ом доступа:</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OAuthRequest request = new OAuthRequest(Verb.GET, PROTECTED_RESOURCE_URL);
</span><span class='line'>service.signRequest(accessToken, request);
</span><span class='line'>request.addHeader("GData-Version", "3.0");
</span><span class='line'>Response response = request.send();</span></code></pre></td></tr></table></div></figure></p>

<p>Где метод <code>signRequest</code> добавляет в header запроса токен:</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void signRequest(Token token, OAuthRequest request)
</span><span class='line'>  {
</span><span class='line'>  config.log("signing request: " + request.getCompleteUrl());
</span><span class='line'>
</span><span class='line'>  // Do not append the token if empty. This is for two legged OAuth calls.
</span><span class='line'>  if (!token.isEmpty())
</span><span class='line'>  {
</span><span class='line'>      request.addOAuthParameter(OAuthConstants.TOKEN, token.getToken());
</span><span class='line'>  }
</span><span class='line'>  config.log("setting token to: " + token);
</span><span class='line'>  addOAuthParams(request, token);
</span><span class='line'>  appendSignature(request);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure></p>

<p>Ну вот и все. Интересно было читать код Scribe. Конечно пришлось пару раз вспомнить заветы товарища Фаулера, но куда без этого?</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Прицельный обзор: Reporter'ы в библиотеке Metrics]]></title>
    <link href="http://knowlix.github.io/blog/2012/08/24/metrics-reporting/"/>
    <updated>2012-08-24T00:22:00+04:00</updated>
    <id>http://knowlix.github.io/blog/2012/08/24/metrics-reporting</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/codahale/metrics">Metrics</a> - библиотека проведения измерения различных метрик как приложения, так и самого JVM от разработчиков Yammer.</p>

<!--more-->


<p>Build tool - Maven с использованием мультимодульности.</p>

<p>Помимо неплохого JavaDoc’а ведется внешняя документация с использованием <a href="http://sphinx.pocoo.org/intro.html">Sphinx</a> - генератора документации на <em>python</em>. Текст документации ведется в <em>reStructuredText</em> разметке. Этот язык разметки сильно упрощен относительно HTML, при этом текст с разметкой не захламлен тегами и читается очень естественно. Сильно напоминает <em>markdown</em>. Документация преобразуется в html посредством генератора из скрипта <em>Makefile</em>.</p>

<p>Основной модуль проекта реализует его архитектуру и основные возможности библиотеки. Остальные модули - это дополнительные возможности, как правило привязанные к конкретным технологиям и библиотекам (например, вывод с помощью log4j или сбор web-ориентированных метрик).</p>

<p>Подход к использованию библиотеки напоминает подход, применяемый в <em>Mockito</em>. Пользователь библиотеки работает с делегатом, как с единой точкой доступа к функционалу библиотеки. Т.е. наружу смотрит класс <code>Metrics</code> либо <code>HealthChecks</code> с набором статичных методов. Реализация этих методов вынесена в отдельный класс, экземпляр которого создается внутри основного класса, например в классе <code>Metrics</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private static final MetricsRegistry DEFAULT_REGISTRY = new MetricsRegistry();</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Сам класс <em>Metrics</em> передает управление делегируемому объекту при вызове его методов:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static &lt;T> Gauge&lt;T> newGauge(Class&lt;?> klass,&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                                String name,
</span><span class='line'>                                Gauge&lt;T&gt; metric) {
</span><span class='line'>return DEFAULT_REGISTRY.newGauge(klass, name, metric);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Библиотека оперирует несколькими измерительными сущностями:</p>

<p>Метриками:
1. <code>Gauges</code> для контроля значений используемых объектов
2. <code>Counters</code> для ведения счетчиков. Используется AtomicLong для подсчета
3. <code>Meters</code> для измерения скорости работы того или иного компонента
4. <code>Histograms</code> для измерения статистического распределения значений в потоке данных
5. <code>Timers</code> для измерения продолжительности и скорости выполнения кода</p>

<p>и <code>HealthChecks</code> для централизованного контроля работоспособности системы.</p>

<p>Прицип работы:</p>

<ol>
<li>Объявляем метрики</li>
<li>Указываем точки определения метрик в коде</li>
<li>Собираем статистику с помощью <code>Reporter’ов</code></li>
</ol>


<p><code>Reporter</code> - объект, который следит за метриками и в случае их появления или изменения оповещает пользователя, доступным reporter’у способом.</p>

<p>Основным <code>Reporter’ом</code> является <code>JMXReporter</code>, который позволяет получать
результаты измерения в JMX консоли. При загрузке класса <code>Metrics</code>
<code>JMXReporter</code> подписывается на события регистра метрик, реализуя при
этом интерфейс слушателя событий регистра метрик.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>JmxReporter.startDefault(DEFAULT_REGISTRY);
</span><span class='line'>Runtime.getRuntime().addShutdownHook(SHUTDOWN_HOOK);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Тогда же вешается хук на событие завершения приложения, чтобы иметь возможность освободить зарегистрированные MBean’ы JMX сервера. При этом <code>SHUTDOWN_HOOK</code> - это поток, реализующий логику, выполняемую при выключении приложения.</p>

<p>При создании метрики, та попадает в регистр метрик. Регистр метрик оповещает слушателей о добавлении новой метрики. <code>JMXReporter</code> получает по событию добавления ссылку на метрику. При этом <code>JMXReporter</code> описывает внутренние классы MBean’ов для каждого вида метрики, чтобы можно было снимать с них показания через JMX консоль. В конструкторе они получают ссылку на метрику и в случае вызова метода, передают управление конкретной метрики. MBean’ы регистрируются на JMX сервере и готовы к снятию показаний.</p>

<p>Внутри библиотеки реализованы дополнительные <code>reporter’ы</code> для вывода данных в <em>CSV</em> файлы или консоль. Эти reporter’ы сами периодически опрашивают метрики, получая данные из них. Опрос метрик происходит в отдельном потоке, созданный с помощью <code>SingleThreadScheduledExecutor</code>.</p>

<p>В аргументе принимается фабрика потоков, которая пораждает потоки и добавляет их в единую группу, тем самым разделяя потоки, запущенные разными executor’ами. Т.е. запущенные из разных executor’ов потоки не будут иметь прав на доступ к потокам из другой группы. Группа получается из стандартного <code>SecurityManager’а</code>. Потоки являются демонами.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private static class NamedThreadFactory implements ThreadFactory {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>private final ThreadGroup group;
</span><span class='line'>private final AtomicInteger threadNumber = new AtomicInteger(1);
</span><span class='line'>private final String namePrefix;
</span><span class='line'>
</span><span class='line'>private NamedThreadFactory(String name) {
</span><span class='line'>    final SecurityManager s = System.getSecurityManager();
</span><span class='line'>    this.group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
</span><span class='line'>    this.namePrefix = "metrics-" + name + "-thread-";
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@Override
</span><span class='line'>public Thread newThread(Runnable r) {
</span><span class='line'>    final Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);
</span><span class='line'>    t.setDaemon(true);
</span><span class='line'>    if (t.getPriority() != Thread.NORM_PRIORITY) {
</span><span class='line'>        t.setPriority(Thread.NORM_PRIORITY);
</span><span class='line'>    }
</span><span class='line'>    return t;
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Основной метод снятия показаний с метрик и вывод их в том или ином виде переопределяется в конкретном классе reporter’а. Все метрики зарегистрированны в реестре метрик и любой репортер в момент создания связывается с конкретным реестром. А ссылка на единый реестр метрик хранится в базовых классах <code>Metrics</code> и <code>HealthChecks</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Прицельный обзор: Зачем Spring'у proxy объекты]]></title>
    <link href="http://knowlix.github.io/blog/2012/07/17/spring-about-proxy/"/>
    <updated>2012-07-17T00:01:00+04:00</updated>
    <id>http://knowlix.github.io/blog/2012/07/17/spring-about-proxy</id>
    <content type="html"><![CDATA[<p>Как уже стало известно, в основе процесса создания <a href="http://www.springsource.org/spring-framework">Spring</a> бинов лежит <em>CGLib</em> - очень распространенная библиотека для создания классов в режиме реального времени. Ее используют такие библиотеки как <em>Hibernate</em>, <em>iBATIS</em> и <a href="http://cglib.sourceforge.net">многие другие</a>.</p>

<!--more-->


<p>Иногда в <em>spring'e</em> появляется необходимость переопределить некоторые методы бина. Типичный случай - разные жизненные циклы связанных бинов. Например, singleton bean должен работать при каждом вызове своих методов с новым экземпляром связанного с ним не singleton бина. В данном случае <em>Spring</em> не сможет обеспечить такую логику, т.к. связанный бин заинжектируется в момент создания singleton бина.</p>

<blockquote><p>В Spring'е есть возможность указать родной для первого бина метод, при вызове которого будет создаваться и возвращаться новый экземпляр связанного бина. Помимо этого есть возможность переопределять методы с помощью <code>MethodReplacer</code>'a. Подробнее <a href="http://static.springsource.org/spring/docs/1.2.x/reference/beans.html#beans-factory-method-injection">здесь</a>.</p></blockquote>

<p>Эти фичи требуют создания proxy объектов бинов, а реализуется все это безобразие с помощью всем известной библиотеки <em>CGLib</em>. После того, как beanFactory определил все метаданные для создания бина и не нашел его в кеше, то он пытается его создать следующим образом:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if (beanDefinition.getMethodOverrides().isEmpty()) {
</span><span class='line'>    Constructor&lt;?&gt; constructorToUse;
</span><span class='line'>    synchronized (beanDefinition.constructorArgumentLock) {
</span><span class='line'>        constructorToUse = (Constructor&lt;?&gt;) beanDefinition.resolvedConstructorOrFactoryMethod;
</span><span class='line'>        if (constructorToUse == null) {
</span><span class='line'>            final Class clazz = beanDefinition.getBeanClass();
</span><span class='line'>            if (clazz.isInterface()) {
</span><span class='line'>                throw new BeanInstantiationException(clazz, "Specified class is an interface");
</span><span class='line'>            }
</span><span class='line'>            try {
</span><span class='line'>                if (System.getSecurityManager() != null) {
</span><span class='line'>                    constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&gt;() {
</span><span class='line'>                        public Constructor run() throws Exception {
</span><span class='line'>                            return clazz.getDeclaredConstructor((Class[]) null);
</span><span class='line'>                        }
</span><span class='line'>                    });
</span><span class='line'>                }
</span><span class='line'>                else {
</span><span class='line'>                    constructorToUse =  clazz.getDeclaredConstructor((Class[]) null);
</span><span class='line'>                }
</span><span class='line'>                beanDefinition.resolvedConstructorOrFactoryMethod = constructorToUse;
</span><span class='line'>            }
</span><span class='line'>            catch (Exception ex) {
</span><span class='line'>                throw new BeanInstantiationException(clazz, "No default constructor found", ex);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return BeanUtils.instantiateClass(constructorToUse);
</span><span class='line'>}
</span><span class='line'>else {
</span><span class='line'>    return instantiateWithMethodInjection(beanDefinition, beanName, owner);
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>} &lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>В методе проверяется есть ли в <code>BeanDefinition</code> объекте переопределенные методы. Если нет, то объект просто инстанцируется с помощью <em>reflection</em>'а, иначе вызывается метод <code>instantiateWithMethodInjection</code>, в котором и реализована работа создания proxy объектов бинов через <code>CglibSubclassCreator</code>. <code>SubclassCreator</code> имеет основной метод <code>instantiate</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Object instantiate(Constructor ctor, Object[] args) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>   Enhancer enhancer = new Enhancer();
</span><span class='line'>   enhancer.setSuperclass(this.beanDefinition.getBeanClass());
</span><span class='line'>   enhancer.setCallbackFilter(new CallbackFilterImpl());
</span><span class='line'>   enhancer.setCallbacks(new Callback[] {
</span><span class='line'>      NoOp.INSTANCE,
</span><span class='line'>      new LookupOverrideMethodInterceptor(),
</span><span class='line'>  new ReplaceOverrideMethodInterceptor()
</span><span class='line'>   });
</span><span class='line'>
</span><span class='line'>   return (ctor == null) ? 
</span><span class='line'>      enhancer.create() : 
</span><span class='line'>  enhancer.create(ctor.getParameterTypes(), args);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>В этом методе создается Enhancer - объект библиотеки CGLib, который конструирует proxy классы. Указывается класс, от которого стоит унаследоваться. В данном случае это класс самого бина. Далее указываются обработчики переопределяемых методов. На данный момент это три вида <code>MethodInterceptor</code>'a:</p>

<ol>
<li><code>NoOp.INSTANCE</code> - константа библиотеки CGLib, передающая управление реальным методам</li>
<li><code>LookupOverrideMethodInterceptor</code> оборабатывает методы, возвращающие новые экземпляры бинов.</li>
<li><code>ReplaceOverrideMethodInterceptor</code> обрабатывает методы, переопределенные с помощью <code>MethodReplacer</code>'a.</li>
</ol>


<p>Оба эти класса объявляены внутри <code>SubclassCreator</code>'а. Метод <code>enhancer.create()</code> конструирует класс и создает экземпляр объекта этого класса.</p>

<p>Стоит заметить, что <code>beanDefintion</code> и <code>beanFactory</code> хранятся в полях <code>SubclassCreator</code>'а, и объявленные в нем классы имеют доступ к ним. Эти поля помечены модификатором final, что гарантирует доступ только на чтение к значениям этих полей.</p>

<p>Объект бина создан и его можно вернуть для инжектирования в клиентскую программу. При вызове методов бинов, созданных с помощью CGLib, передается управление обработчикам методов, которые указаны у proxy объекта. При создании бина были указаны 3 обработчика и <code>CallbackFilter</code>. При добавлении обработчика он получает индекс, как в массиве. <code>CallbackFilter</code> определяет какой из обработчиков выполнится, указывая его индекс. В spring'e создается свой фильтр обработчиков <code>CallbackFilterImpl</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private class CallbackFilterImpl extends CglibIdentitySupport implements CallbackFilter {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>public int accept(Method method) {
</span><span class='line'>    MethodOverride methodOverride = beanDefinition.getMethodOverrides().getOverride(method);
</span><span class='line'>    if (logger.isTraceEnabled()) {
</span><span class='line'>        logger.trace("Override for '" + method.getName() + "' is [" + methodOverride + "]");
</span><span class='line'>    }
</span><span class='line'>    if (methodOverride == null) {
</span><span class='line'>        return PASSTHROUGH;
</span><span class='line'>    }
</span><span class='line'>    else if (methodOverride instanceof LookupOverride) {
</span><span class='line'>        return LOOKUP_OVERRIDE;
</span><span class='line'>    }
</span><span class='line'>    else if (methodOverride instanceof ReplaceOverride) {
</span><span class='line'>        return METHOD_REPLACER;
</span><span class='line'>    }
</span><span class='line'>    throw new UnsupportedOperationException(
</span><span class='line'>            "Unexpected MethodOverride subclass: " + methodOverride.getClass().getName());
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Как можно заметить, переопределяемые методы представляют собой <code>MethodOverride</code> объект, который определяет его имя, имя объекта, которому он принадлежит и другую мета информацию о методе. Но сам по себе этот класс абстрактный, а наследуют его два класса:</p>

<ol>
<li><code>LookupOverride</code> для объявления порождающих методов</li>
<li><code>ReplaceOverride</code> для объявления методов, переопределяемых произвольной логикой</li>
</ol>


<p>Определяя тип переопределяемого метода, определяется индекс обработчика. Индекс обработчика задан в виде константы.</p>

<p>При вызове обработчика <code>LookupOverrideMethodInterceptor</code> вызывается создание бина с помощью beanFactory текущего бина по имени, которое задано в LookupOverride. Это имя попадает туда из соответствующей директивы конфигурации бинов:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;lookup-method name="createSingleShotHelper" bean="singleShotHelper"/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>При вызове <code>ReplaceOverrideMethodInterceptor</code> получается указанный в <code>ReplaceOverride</code> <code>MethodReplacer</code> и вызывается его основной метод с логикой, куда передается информация о вызванном методе, аргументах и самом объекте. Объект <code>MethodReplacer</code> также определяется в конфигурации директивой:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;replaced-method name="computeValue" replacer="replacementComputeValue"></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Как видно из строчки конфигурации, задается имя бина <code>MethodReplacer</code>'a. Поэтому в <code>ReplaceOverride</code> объекте хранится просто имя, а при обработке вызова метода данным обработчиком по имени бина получается объект с помощью все той же <code>BeanFactory</code>.</p>

<p>Как видно из данного обзора, подход оперирования именами бинов во всех частях конфигурации в некоторых ситуациях может вызывать достаточно большой overhead при работе с proxy объектами.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Прицельный обзор: Как создаются бины в Spring Framework]]></title>
    <link href="http://knowlix.github.io/blog/2012/07/10/spring-creating-beans/"/>
    <updated>2012-07-10T01:09:00+04:00</updated>
    <id>http://knowlix.github.io/blog/2012/07/10/spring-creating-beans</id>
    <content type="html"><![CDATA[<p>Основной интерфейс - <code>BeanFactory</code>. Основной метод - <code>getBean</code>. Его расширяют такие интерфейсы как:</p>




<ul class="enum">
    <li><code>ListableBeanFactory</code> для доступа к спискам экземпляров созданных bean'ов</li>
    <li><code>HierarchicalBeanFactory</code> для организации иерархичных фабрик бинов</li>
    <li><code>ConfigurableBeanFactory</code> определяет методы, конфигурирующие бины</li>
</ul>




<!--more-->




<p>Этих интерфейсов бесчисленное множество. По отдельности они практически не используются, а служат для создания больших многофункциональных объектов фабрик. Для инициации загрузки необходим конфигурационный файл. За обработку источников конфигурации бинов отвечают BeanDefinition объекты:</p>




<ul class="enum">
    <li><code>PropertiesBeanDefinitionReader</code> для конфигурирования бинов в property файлах</li>
    <li><code>XmlBeanDefinitionReader</code> для конфигурирования бинов с помощью xml</li>
</ul>




<p>Естественно, наиболее популярен XML BeanDefinition, но очевидно, что скоро и от XML откажутся, как от пережитка прошлого, в пользу <em>Java</em> синтаксиса. Но это будущее, а сейчас вершина <code>FactoryBean</code> иерархии - <code>XmlBeanFactory</code>. Этот объект определяет все специфичные для создания бинов с помощью xml конфигураций реализации, такие как <code>XmlBeanDefinitionReader</code>. Настройки бина, обявленного в конфиге, хранятся в BeanDefinition объекте. Все эти объекты хранятся в реестре бинов - <code>BeanDefinitionRegistry</code>.</p>




<p>Как же строятся бины?</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public &lt;T> T getBean(Class&lt;T> requiredType) throws BeansException {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>Assert.notNull(requiredType, "Required type must not be null");
</span><span class='line'>String[] beanNames = getBeanNamesForType(requiredType);
</span><span class='line'>if (beanNames.length &gt; 1) {
</span><span class='line'>    ArrayList&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;();
</span><span class='line'>    for (String beanName : beanNames) {
</span><span class='line'>        if (getBeanDefinition(beanName).isAutowireCandidate()) {
</span><span class='line'>            autowireCandidates.add(beanName);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    if (autowireCandidates.size() &gt; 0) {
</span><span class='line'>        beanNames = autowireCandidates.toArray(new String[autowireCandidates.size()]);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>if (beanNames.length == 1) {
</span><span class='line'>    return getBean(beanNames[0], requiredType);
</span><span class='line'>}
</span><span class='line'>else if (beanNames.length == 0 &amp;&amp; getParentBeanFactory() != null) {
</span><span class='line'>    return getParentBeanFactory().getBean(requiredType);
</span><span class='line'>}
</span><span class='line'>else {
</span><span class='line'>    throw new NoSuchBeanDefinitionException(requiredType, "expected single bean but found " +
</span><span class='line'>            beanNames.length + ": " + StringUtils.arrayToCommaDelimitedString(beanNames));
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Сразу же бросается в глаза некий утилитарный класс <code>Assert</code>, который лишь визуально напоминает конструкцию языка java <code>assert</code>. На этом сходство заканчивается, т.к. внутри все те же стандартные java исключения типа <code>IllegalArgumentException</code>. С помощью метода <code>getBeanNamesForType</code> получается массив всех имен бинов из реестра и отбираются только те, которые соответствуют по типу и другим логическим параметрам, что, к примеру, не позволяет создавать бины из абстрактных классов. Далее, если не нашлось ни одного имени, то пытаемся получить бин из родительской фабрики бинов. <code>parentBeanFactory</code> задается в конструкторе фабрики при её создании. Если имен бинов найдено несколько, то значит конфиг некорректен. И тем не менее пытаемся в данном случае сузить круг поиска только бинами, которые помечены как внедряемые в другие классы.</p>




<p>Теперь, когда у нас есть имя бина и его тип, мы можем попытаться получить экземпляр бина. Метод создания бина достаточно большой (135 строк без сторонних используемых методов), поэтому покажу только кусочки. В первую очередь пытаемся получить объект, если это singleton и он был загружен ранее. Т.к. объект бина может быть фабрикой, то идет проверка на соответствие интерфейсу <code>FactoryBean</code>. Если это действительно фабрика, то вызывается ее фабричный метод.</p>




<p>Порадовала проверка на параллельный запуск создания одного и того же бина в одном потоке. </p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (isPrototypeCurrentlyInCreation(beanName)) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>throw new BeanCurrentlyInCreationException(beanName);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Таким образом предотвращаются циклические ссылки. Статус создания того или иного бина хранится в NamedThreadLocal переменной. </p>




<blockquote>
Далее идут иерархические хитросплетения, которые сводятся к одному, к библиотке <a href="http://cglib.sourceforge.net/" rel="nofollow">CGLib</a>. С помощью неё создаются бины в spring'e.
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Прицельный обзор: Как работает Dependency Injection в Spring Framework]]></title>
    <link href="http://knowlix.github.io/blog/2012/07/09/spring-di/"/>
    <updated>2012-07-09T00:37:00+04:00</updated>
    <id>http://knowlix.github.io/blog/2012/07/09/spring-di</id>
    <content type="html"><![CDATA[<p>Для того, чтобы ответить на этот вопрос, нужно определить точку входа. Для начала организуется контекст приложения - вручную для стандартных приложений или автоматически при использовании <em>Spring</em>'а в Web. Сразу хочу отметить, <a href="http://www.springsource.org/spring-framework/" rel="nofollow">Spring Framework</a> отличается высоким уровнем абстракции. Немалая часть реализации организуется путем глубокого наследования (5-6 уровней). Так <code>ApplicationContext</code> компонует в себе общий функционал по работе с состоянием приложения путем реализации нескольких интерфейсов. Затем, делая cast к тому или иному интерфейсу, можно работать с определенным функционалом. К примеру:</p>




<!--more-->


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
</span><span class='line'>BeanFactory beanFactory = context;
</span><span class='line'>PrintService printService = (PrintService) beanFactory.getBean("printService");
</span><span class='line'>printService.print();</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Во время создания контекста приложения инициируется его конфигурация, где описываются бины или пакеты, в которых стоит их искать, после чего создаются все связанные компоненты. В терминах Spring'а выполняется refresh контекста. Создается фабрика bean'ов, определяются post processor'ы фабрики. Дело в том, что бины загружаются при старте приложения в память. Они конфигурируются через component-scan директиву в xml или напрямую директивой bean. Все начинается с парсинга конфига с помощью <code>ConfigurationClassPostProcessor</code>'а. Создается парсер конфига <code>ConfigurationClassParser</code> и вызывается его метод <code>parse</code>. Отдельные объекты обрабатывают разные директивы конфига и загружают бины с помощью reflection'а. BeanFactory реализует интерфейс BeanDefinitionRegistry, который описывает структуру объекта для доступа к найденным бинам. Этот объект наполняется через <code>ConfigurationClassParser</code>.</p>




<p>Метод <code>beanFactory.getBean("printService")</code> просто получает экземпляр проинициализированного бина из Map'ы.</p>




<p>DI базируется на трех частях <em>Spring</em>'а - <em>Core</em>, <em>Context</em>, <em>Beans</em>. Куча абстракции, наследования. Используются крупные объекты, реализующие разные функциональные роли. Все это немного усложняет копание в Spring'e. Спасает хороший JavaDoc.</p>

]]></content>
  </entry>
  
</feed>
